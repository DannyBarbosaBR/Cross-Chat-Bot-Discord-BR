//parte 1 Inicializa√ß√£o e configura√ß√£o do cliente.
import { Client, GatewayIntentBits, Events, EmbedBuilder } from 'discord.js';
import { config } from 'dotenv';
import fs from 'fs';

// Manter o bot ativo no Replit
//import express from 'express';
//const app = express();

// Cria uma rota simples para manter o bot online
//app.get('/', (req, res) => res.send('O bot est√° rodando!'));

//const PORT = process.env.PORT || 3000;
//app.listen(PORT, () => {
//    console.log(`Servidor HTTP rodando na porta ${PORT}`);
//});

// Carregue suas vari√°veis de ambiente
//config();
const TOKEN = ;
const CLIENT_SECRET = ;
const WEBHOOK_URL = `';`;
const OWNER_ID = '1067849662347878401'; // Coloque o seu ID de usu√°rio aqui

// Limite de palavras
const MAX_WARNINGS = 3; // N√∫mero m√°ximo de avisos permitidos por servidor
const MAX_WORDS = 50; // Limite de palavras
const cooldowns = new Map(); // Mapa para gerenciar cooldowns
const warnedServers = new Map(); // Mapa para rastrear avisos por servidor

//const TOKEN = process.env.TOKEN;
//const CLIENT_SECRET = process.env.CLIENT_SECRET;
//const WEBHOOK_URL = process.env.WEBHOOK_URL;

let channelConnections = {};
let globalConnections = [];
let bannedServers = [];

// Crie uma nova inst√¢ncia do cliente Discord
const client = new Client({
intents: [
GatewayIntentBits.Guilds,
GatewayIntentBits.GuildMessages,
GatewayIntentBits.MessageContent,
GatewayIntentBits.GuildMembers,
],
});
//parte 2 Fun√ß√µes para carregar e salvar conex√µes.
// Fun√ß√£o para carregar conex√µes
function loadConnections() {
if (fs.existsSync('Salvamento.json')) {
try {
const data = fs.readFileSync('Salvamento.json', 'utf8');
if (data.trim().length === 0) {
channelConnections = {};
globalConnections = [];
bannedServers = [];
} else {
const parsedData = JSON.parse(data);
channelConnections = parsedData.channelConnections || {};
globalConnections = parsedData.globalConnections || [];
bannedServers = parsedData.bannedServers || [];
}
} catch (error) {
console.error("Erro ao carregar conex√µes: ", error);
channelConnections = {};
globalConnections = [];
bannedServers = [];
}
}
}

// Fun√ß√£o para salvar conex√µes
function saveConnections() {
fs.writeFileSync('Salvamento.json', JSON.stringify({ channelConnections, globalConnections, bannedServers }));
}
//parte 3 Fun√ß√µes utilit√°rias, como formata√ß√£o de data e regras do servidor
// Fun√ß√£o que formata a data e hora corretamente
function formatDateTime() {
const now = new Date();
const hours = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
const date = now.toLocaleDateString([], { day: '2-digit', month: '2-digit', year: 'numeric' });
return `üïò ${date} | üóìÔ∏è ${hours}`;
}
// Regras do Danny-Chat
const dchatRules = `
1. **Use o bom senso:** Seja considerado com os outros e suas opini√µes. Sem ofensas, linguagem extrema ou qualquer a√ß√£o que possa perturbar o conforto do chat.
2. **Sem spam ou flooding:** Evite mensagens repetidas, sem sentido ou excessivamente longas.
3. **Mantenha assuntos privados:** Evite compartilhar informa√ß√µes pessoais na rede.
4. **Sem ass√©dio:** Trolling, insultos ou ass√©dio de qualquer tipo n√£o ser√£o tolerados.
5. **Sem conte√∫do NSFW/NSFL:** Postar conte√∫do NSFW/NSFL expl√≠cito resultar√° em banimento imediato.
6. **Respeite t√≥picos sens√≠veis:** N√£o trivialize automutila√ß√£o, suic√≠dio, viol√™ncia ou outros t√≥picos ofensivos.
7. **Reporte preocupa√ß√µes:** Se voc√™ observar uma viola√ß√£o dessas regras, reporte ao moderador do hub apropriado ou √† equipe do Danny-Chat para a√ß√£o adicional.

Qualquer d√∫vida? Junte-se ao nosso [servidor de suporte](https://discord.gg/8GWFWNmjTa).
`;

// Lista de palavr√µes (incluindo os fornecidos)
const forbiddenWords = [
'aid√©tico', 'aid√©tica', 'aleijado', 'aleijada', 'analfabeto', 'analfabeta',
'anus', 'an√£o', 'an√£', 'arrombado', 'apenado', 'apenada', 'baba-ovo', 
'babaca', 'babaovo', 'bacura', 'bagos', 'baianada', 'baitola', 'barbeiro',
'barraco', 'beata', 'bebum', 'besta', 'bicha', 'bisca', 'bixa', 'boazuda',
'boceta', 'boco', 'boiola', 'bokete', 'bolagato', 'bolcat', 'boquete', 
'bosseta', 'bosta', 'bostana', 'bo√ßal', 'branquelo', 'brecha', 'brexa',
'brioco', 'bronha', 'buca', 'buceta', 'bugre', 'bunda', 'bunduda', 'burra',
'burro', 'busseta', 'b√°rbaro', 'b√™bado', 'b√™bedo', 'caceta', 'cacete', 
'cachorra', 'cachorro', 'cadela', 'caga', 'cagado', 'cagao', 'cag√£o',
'cagona', 'caipira', 'canalha', 'canceroso', 'caralho', 'casseta', 
'cassete', 'ceguinho', 'checheca', 'chereca', 'chibumba', 'chibumbo', 
'chifruda', 'chifrudo', 'chochota', 'chota', 'chupada', 'chupado', 
'ciganos', 'clitoris', 'clit√≥ris', 'cocaina', 'coca√≠na', 'coco', 
'coc√¥', 'comunista', 'corna', 'cornagem', 'cornisse', 'corno', 'cornuda', 
'cornudo', 'corn√£o', 'corrupta', 'corrupto', 'coxo', 'cretina', 
'cretino', 'criolo', 'crioulo', 'cruz-credo', 'cu', 'c√∫', 'culhao', 
'culh√£o', 'curalho', 'cuzao', 'cuz√£o', 'cuzuda', 'cuzudo', 'debil', 
'd√©bil', 'debiloide', 'debil√≥ide', 'deficiente', 'defunto', 'demonio', 
'dem√¥nio', 'denegrir', 'denigrir', 'detento', 'difunto', 'doida', 
'doido', 'egua', '√©gua', 'elemento', 'encostado', 'esclerosado', 
'escrota', 'escroto', 'esporrada', 'esporrado', 'esporro', 'estupida', 
'est√∫pida', 'estupidez', 'estupido', 'est√∫pido', 'facista', 'fanatico', 
'fan√°tico', 'fascista', 'fedida', 'fedido', 'fedor', 'fedorenta', 
'feia', 'feio', 'feiosa', 'feioso', 'feioza', 'feiozo', 'felacao', 
'fela√ß√£o', 'fenda', 'foda', 'fodao', 'fod√£o', 'fode', 'fodi', 
'fodida', 'fodido', 'fornica', 'forni√ß√£o', 'fudendo', 'fude√ß√£o', 
'fudida', 'fudido', 'furada', 'furado', 'furnica', 'furnicar', 
'furo', 'furona', 'fur√£o', 'gai', 'gaiata', 'gaiato', 'gay', 
'gilete', 'goianada', 'gonorrea', 'gonorreia', 'gonorr√©ia', 
'gosmenta', 'gosmento', 'grelinho', 'grelo', 'gringo', 
'homo-sexual', 'homosexual', 'homosexualismo', 'homossexual', 
'homossexualismo', 'idiota', 'idiotice', 'imbecil', 'inculto', 
'iscrota', 'iscroto', 'japa', 'judiar', 'ladra', 'ladrao', 
'ladroeira', 'ladrona', 'ladr√£o', 'lalau', 'lazarento', 'leprosa', 
'leproso', 'lesbica', 'l√©sbica', 'louco', 'macaca', 'macaco', 
'machona', 'macumbeiro', 'malandro', 'maluco', 'maneta', 
'marginal', 'masturba', 'meleca', 'meliante', 'merda', 'mija', 
'mijada', 'mijado', 'mijo', 'minorias', 'mocrea', 'mocreia', 
'mocr√©ia', 'moleca', 'moleque', 'mondronga', 'mondrongo', 
'mongol', 'mongoloide', 'mongol√≥ide', 'mulata', 'mulato', 
'naba', 'nadega', 'n√°dega', 'nazista', 'negro', 'nhaca', 
'nojeira', 'nojenta', 'nojento', 'nojo', 'olhota', 'otaria', 
'otario', 'ot√°ria', 'ot√°rio', 'paca', 'palhaco', 'palha√ßo', 
'paspalha', 'paspalhao', 'paspalho', 'pau', 'peia', 'peido', 
'pemba', 'pentelha', 'pentelho', 'perereca', 'perneta', 
'peru', 'pe√£o', 'pica', 'picao', 'pic√£o', 'pilantra', 
'pinel', 'pinto', 'pintudo', 'pint√£o', 'piranha', 'piroca', 
'piroco', 'piru', 'pivete', 'porra', 'prega', 'preso', 
'prequito', 'priquito', 'prostibulo', 'prostituta', 
'prostituto', 'punheta', 'punhetao', 'punhet√£o', 'pus', 
'pustula', 'puta', 'puto', 'puxa-saco', 'puxasaco', 
'penis', 'p√™nis', 'rabao', 'rab√£o', 'rabo', 'rabuda', 
'rabudao', 'rabud√£o', 'rabudo', 'rabudona', 'racha', 
'rachada', 'rachadao', 'rachadinha', 'rachadinho', 'rachado', 
'ramela', 'remela', 'retardada', 'retardado', 'rid√≠cula', 
'roceiro', 'rola', 'rolinha', 'rosca', 'sacana', 'safada', 
'safado', 'sapatao', 'sapat√£o', 'sifilis', 's√≠filis', 
'siririca', 'tarada', 'tarado', 'testuda', 'tesuda', 
'tesudo', 'tezao', 'tezuda', 'tezudo', 'traveco', 
'trocha', 'trolha', 'troucha', 'trouxa', 'troxa', 
'tuberculoso', 'tupiniquim', 'turco', 'vaca', 'vadia', 
'vagal', 'vagabunda', 'vagabundo', 'vagina', 'veada', 
'veadao', 'veado', 'viada', 'viadagem', 'viadao', 
'viad√£o', 'viado', 'viad√£o', 'v√≠ado', 'xana', 
'xaninha', 'xavasca', 'xerereca', 'xexeca', 'xibiu', 
'xibumba', 'xi√≠ta', 'xochota', 'xota', 'xoxota'
];

client.on('messageCreate', async (message) => {
    // Ignorar mensagens do bot para evitar loops
    if (message.author.bot) return;

    // Verificar se a mensagem est√° em um canal global
    if (!globalConnections.includes(message.channel.id)) return;

    // Inicializa contador de avisos para o servidor
    if (!warnedServers.has(message.guild.id)) {
        warnedServers.set(message.guild.id, {
            forbiddenWordWarnings: 0,
            repeatedMessageWarnings: 0,
            wordLimitWarnings: 0,
            messageHistory: []
        });
    }
    const serverWarnings = warnedServers.get(message.guild.id);

    // Verificar se a mensagem cont√©m alguma palavra proibida
    const containsForbiddenWord = forbiddenWords.some(word => message.content.toLowerCase().includes(word));

    if (containsForbiddenWord) {
        const remainingWarnings = 5 - serverWarnings.forbiddenWordWarnings;
        const warningEmbed = new EmbedBuilder()
            .setColor('#FF0000') // Cor do embed para aviso (vermelho)
            .setTitle('üö´ Aviso:')
            .setDescription(`Palavras proibidas n√£o s√£o permitidas. Voc√™ s√≥ tem mais ${remainingWarnings} avisos antes de desconectar.`)
            .setFooter({ text: `Mensagem enviada por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        await message.channel.send({ embeds: [warningEmbed] });

        // Incrementa o contador de avisos por palavr√µes
        serverWarnings.forbiddenWordWarnings += 1;

        // Verifica se o n√∫mero de avisos por palavr√µes ultrapassa o limite
        if (serverWarnings.forbiddenWordWarnings >= 5) { // Limite de 5 avisos
            await disconnectServer(message); // Desconecta o servidor se atingir o limite
            return;
        }
    }

    // Detectar mensagens repetidas
    const messageContent = message.content.toLowerCase();
    const messageHistory = serverWarnings.messageHistory;
    
    // Adiciona a nova mensagem ao hist√≥rico
    messageHistory.push(messageContent);
    
    // Verifica se a mesma mensagem foi enviada 5 vezes consecutivas
    const repeatedCount = messageHistory.filter(msg => msg === messageContent).length;

    if (repeatedCount >= 5) {
        const remainingWarnings = 5 - serverWarnings.repeatedMessageWarnings;
        const repeatWarningEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('üö´ Aviso:')
            .setDescription(`Mensagens repetidas n√£o s√£o permitidas. Voc√™ s√≥ tem mais ${remainingWarnings} avisos antes de desconectar.`)
            .setFooter({ text: `Mensagem enviada por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        await message.channel.send({ embeds: [repeatWarningEmbed] });

        // Incrementa o contador de avisos por mensagens repetidas
        serverWarnings.repeatedMessageWarnings += 1;

        // Verifica se o n√∫mero de avisos por mensagens repetidas ultrapassa o limite
        if (serverWarnings.repeatedMessageWarnings >= 5) { // Limite de 5 avisos
            await disconnectServer(message); // Desconecta o servidor se atingir o limite
            return;
        }
    }
    
    const messageWordCount = message.content.split(/\s+/).length;
    
    if (messageWordCount > MAX_WORDS) {
        const remainingWarnings = 5 - serverWarnings.wordLimitWarnings;
        const wordLimitEmbed = new EmbedBuilder()
            .setColor('#FFFF00') // Cor do embed para limite de palavras (amarelo)
            .setTitle('‚ö†Ô∏è Aviso:')
            .setDescription(`Sua mensagem excede o limite de ${MAX_WORDS} palavras. \n Voc√™ s√≥ tem mais ${remainingWarnings} avisos antes de desconectar.`)
            .setFooter({ text: `Mensagem enviada por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

        await message.channel.send({ embeds: [wordLimitEmbed] });
        
        // Incrementa o contador de avisos por limite de palavras
        serverWarnings.wordLimitWarnings += 1;

        // Verifica se o n√∫mero de avisos por limite de palavras ultrapassa o limite
        if (serverWarnings.wordLimitWarnings >= 5) { // Limite de 5 avisos
            await disconnectServer(message); // Desconecta o servidor se atingir o limite
            return;
        }
    }

}); // Fechamento do evento 'messageCreate'

// Fun√ß√£o para desconectar o servidor automaticamente
const disconnectServer = async (message) => {
    globalConnections = globalConnections.filter(id => id !== message.channel.id); // Remove o canal da lista global
    saveConnections(); // Salva o estado das conex√µes

    const disconnectEmbed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('üîå Servidor Desconectado')
        .setDescription(`O servidor **${message.guild.name}** foi desconectado da conex√£o global por excesso de avisos.`)
        .setFooter({
            text: `üå† Danny Barbosa | ${formatDateTime()}`,
            iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
        })
        .setTimestamp();

    // Notifica todos os canais restantes na conex√£o global
    for (const id of globalConnections) {
        try {
            const channel = await client.channels.fetch(id);
            await channel.send({ embeds: [disconnectEmbed] });
        } catch (err) {
            console.log(`Erro ao enviar mensagem para o canal ${id}: ${err.message}`);
        }
    }
};

//parte 4 Defini√ß√£o dos comandos do bot, com suas respectivas funcionalidades
const commands = {
criador: {
description: 'Mostra quem √© o criador do bot',
execute: (message) => {
const embed = new EmbedBuilder()
.setColor('#800080')
.setTitle('üå† Danny Barbosa')
.setThumbnail("https://avatars.githubusercontent.com/u/132908376?v=4")
.setDescription('üåü Criado por <@1067849662347878401> ! \n [Acesse o Github do projeto!](https://github.com/DannyBarbosaBR/Cross-Chat-Bot-Discord-BR/)')
.setFooter({
text: `üå† Danny Barbosa | ${formatDateTime()}`,
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();
message.channel.send({ embeds: [embed] });
},
},

informa√ß√µes: {
description: 'Mostra informa√ß√µes sobre o bot.',
execute: async (message) => {
const infoEmbed = new EmbedBuilder()
.setColor('#00FF00') // Cor do embed para informa√ß√µes (verde)
.setTitle('üåê Informa√ß√µes sobre o Danny Chat')
.setDescription(`
               O Danny Chat √© um bot que conecta servidores, permitindo que as mensagens enviadas em um canal sejam vis√≠veis em todos os servidores conectados.
               
               **Como Funciona:**
               - Ao enviar uma mensagem neste canal, ela ser√° replicada em todos os canais que est√£o conectados globalmente.
               - Para que o bot consiga enviar sua mensagem, ele transforma voc√™ em "app". Isso √© necess√°rio, pois sem essa transforma√ß√£o, a mensagem n√£o poderia ser enviada para os outros servidores.
               
               **Conectando Canais:**
               - Voc√™ pode conectar seu canal a outros servidores utilizando o comando \`!global\`.
               - Uma vez conectado, todas as mensagens enviadas aqui ser√£o compartilhadas com os servidores que fazem parte da conex√£o.
           `)
.setFooter({
text: `üå† Danny Barbosa | ${formatDateTime()}`,
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();

await message.channel.send({ embeds: [infoEmbed] });
},
},

hor√°rio: {
description: 'Mostra o hor√°rio de funcionamento atual.',
execute: async (message) => {
const hoje = new Date();
const diasDaSemana = ['Domingo', 'Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado'];
const diaAtual = diasDaSemana[hoje.getDay()]; // Obt√©m o dia da semana atual

const horarios = {
Domingo: 'Fora de hor√°rio',
Segunda: '19:00 - 22:00',
Ter√ßa: '19:00 - 22:00',
Quarta: '19:00 - 22:00',
Quinta: '19:00 - 22:00',
Sexta: 'Fora de hor√°rio',
S√°bado: '14:00 - 21:00',
};

const horarioHoje = horarios[diaAtual]; // Obt√©m o hor√°rio do dia atual
const ultimoHorario = {
Segunda: '22:00',
Ter√ßa: '22:00',
Quarta: '22:00',
Quinta: '22:00',
S√°bado: '21:00',
}[diaAtual] || null; // Define o √∫ltimo hor√°rio

const resposta = `üïò **Hor√°rio de Atividade para Hoje: \n(${diaAtual}):** ${horarioHoje}`;

const embed = new EmbedBuilder()
.setColor('#FFC0CB')
.setTitle('üìÖ Hor√°rio de Funcionamento')
.setDescription(resposta)
.setFooter({
text: `üå† Danny Barbosa | ${formatDateTime()}`,
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();

message.channel.send({ embeds: [embed] });

// Verifica se o hor√°rio est√° fora de hor√°rio
if (horarioHoje === 'Fora de hor√°rio') {
// Mensagem de parada embutida
const shutdownEmbed = new EmbedBuilder()
.setTitle("üì° Bot Fora do Ar!")
.setDescription("O Danny-Chat est√° **desligado**. Voltaremos depois! üö´")
.setColor(0xFF0000)
.setThumbnail("https://avatars.githubusercontent.com/u/132908376?v=4")
.setTimestamp()
.setFooter({ text: `${message.guild.name} - Conectando Comunidades` });

message.channel.send({ embeds: [shutdownEmbed] });
return; // Encerra a execu√ß√£o para evitar mais envios
}

// Verifica se o hor√°rio atual ultrapassou o √∫ltimo hor√°rio
if (ultimoHorario && hoje.toTimeString().split(' ')[0] > ultimoHorario) {
// Mensagem de parada embutida
const shutdownEmbed = new EmbedBuilder()
.setTitle("üì° Bot Fora do Ar!")
.setDescription("O Danny-Chat est√° **desligado**. Voltaremos depois! üö´")
.setColor(0xFF0000)
.setThumbnail("https://avatars.githubusercontent.com/u/132908376?v=4")
.setTimestamp()
.setFooter({ text: `${message.guild.name} - Conectando Comunidades` });

message.channel.send({ embeds: [shutdownEmbed] });
}
},
},

servidores: {
description: 'Mostra todos os servidores conectados',
execute: (message) => {
const serverCount = client.guilds.cache.size;
const serverList = client.guilds.cache.map(guild => `${guild.name} (ID: ${guild.id})`).join('\n');

const embed = new EmbedBuilder()
.setColor('#2E8B57')
.setTitle('üåç Servidores Globlais')
.setDescription(`Conectado em ${serverCount} servidores:\n\n${serverList}\n\n [Acesse o Github do projeto!](https://github.com/DannyBarbosaBR/Cross-Chat-Bot-Discord-BR/)
`)
.setFooter({
text: `üå† Danny Barbosa | ${formatDateTime()}`,
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();
message.channel.send({ embeds: [embed] });
}, // Corrigido: removeu o ponto e v√≠rgula aqui
},
global: {
    description: 'Conecta o canal atual a outros servidores.',
    execute: async (message) => {
        // Verifica se o servidor est√° banido
        if (bannedServers.includes(message.guild.id)) {
            const bannedServerEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Servidor Banido')
                .setDescription('Este servidor n√£o tem permiss√£o para usar este comando.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [bannedServerEmbed] });
        }

        // Verifica se o usu√°rio tem permiss√£o para usar o comando
        if (message.author.id !== OWNER_ID && !message.member.permissions.has('ADMINISTRATOR')) {
            const noPermissionEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Permiss√£o Negada')
                .setDescription('Voc√™ n√£o tem permiss√£o para usar este comando.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [noPermissionEmbed] });
        }

        if (globalConnections.includes(message.channel.id)) {
            const alreadyConnectedEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('üîó Conex√£o Global')
                .setDescription('Este canal j√° est√° conectado globalmente.\nPara mais detalhes, use `!informa√ß√µes`.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [alreadyConnectedEmbed] });
        }

        globalConnections.push(message.channel.id);
        const connectedEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üåê Canal Conectado')
            .setThumbnail(message.guild.iconURL({ dynamic: true, format: 'png', size: 1024 }))
            .setDescription(`Canal <#${message.channel.id}> conectado globalmente. \nPara mais detalhes, use \`!informa√ß√µes\`.`)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        message.channel.send({ embeds: [connectedEmbed] });

        const embedRules = new EmbedBuilder()
            .setColor('#FFFF00')
            .setTitle('üìú Regras do Danny-Chat')
            .setDescription(dchatRules)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        message.channel.send({ embeds: [embedRules] });

        const numberOfConnections = globalConnections.length;
        const notificationEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üëã Novo Servidor Conectado')
            .setDescription(`O servidor **${message.guild.name}** entrou na conex√£o!\nAgora temos **${numberOfConnections}** servidores conectados.`)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        // Verifica se os canais existem antes de enviar a mensagem
        const validChannels = [];
        for (const channelId of globalConnections) {
            try {
                const channel = await client.channels.fetch(channelId);
                validChannels.push(channel); // Armazena canais v√°lidos
            } catch (error) {
                console.log(`Canal ${channelId} n√£o encontrado, removendo da lista de conex√µes.`);
                globalConnections = globalConnections.filter(id => id !== channelId); // Remove o canal da lista
            }
        }

        // Envia a mensagem apenas para canais v√°lidos
        for (const channel of validChannels) {
            try {
                await channel.send({ embeds: [notificationEmbed] });
            } catch (err) {
                console.log(`Erro ao enviar mensagem para o canal ${channel.id}: ${err.message}`);
            }
        }

        saveConnections();
    },
},
    
conectar: {
    description: 'Conecta o canal a um outro do servidor',
    execute: (message) => {
        if (message.author.id !== OWNER_ID && !message.member.permissions.has('ADMINISTRATOR')) {
            const noPermissionEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Permiss√£o Negada')
                .setDescription('Voc√™ n√£o tem permiss√£o para usar este comando.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [noPermissionEmbed] });
        }

        const targetChannel = message.mentions.channels.first();
        if (!targetChannel) {
            const noTargetEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚ùó Canal N√£o Encontrado')
                .setDescription('Por favor, mencione um canal para conectar.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [noTargetEmbed] });
        }

        if (!channelConnections[message.guild.id]) {
            channelConnections[message.guild.id] = [];
        }

        channelConnections[message.guild.id].push({
            sourceChannelId: message.channel.id,
            targetChannelId: targetChannel.id,
        });

        const connectEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üîó Canal Conectado')
            .setDescription(`Canal <#${message.channel.id}> conectado ao canal <#${targetChannel.id}>.`)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        message.channel.send({ embeds: [connectEmbed] });
        saveConnections();
    },
},
    
desconectar: {
    description: 'Desconecta um canal conectado.',
    async execute(message) {
        const channelId = message.channel.id;

        // Verifica se o canal est√° na lista de conex√µes globais
        if (!globalConnections.includes(channelId)) {
            const notConnectedEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå N√£o Conectado')
                .setDescription('Este canal n√£o est√° conectado globalmente.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            return message.channel.send({ embeds: [notConnectedEmbed] });
        }

        // Remove o canal da lista de conex√µes globais
        globalConnections = globalConnections.filter(id => id !== channelId);

        const disconnectSuccessEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üîå Desconectado com Sucesso')
            .setDescription(`Canal <#${channelId}> desconectado com sucesso.`)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        message.channel.send({ embeds: [disconnectSuccessEmbed] });

        // Salva as conex√µes ap√≥s a desconex√£o
        saveConnections();

        // Notifica√ß√£o de desconex√£o para os canais conectados
        const disconnectEmbed = new EmbedBuilder()
            .setColor('#FF0000') // Vermelho para desconex√£o
            .setTitle('üîå Desconectado da Conex√£o')
            .setDescription(`O canal <#${channelId}> do **${message.guild.name}** foi desconectado.`)
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        // Envia a notifica√ß√£o para todos os canais conectados
        for (const id of globalConnections) {
            try {
                const channel = await client.channels.fetch(id);
                await channel.send({ embeds: [disconnectEmbed] });
            } catch (err) {
                console.log(`Erro ao enviar mensagem para o canal ${id}: ${err.message}`);
            }
        }

        // Remove conex√µes associadas ao canal desconectado
        if (channelConnections[message.guild.id]) {
            channelConnections[message.guild.id] = channelConnections[message.guild.id].filter(connection => {
                return connection.sourceChannelId !== channelId && connection.targetChannelId !== channelId;
            });
        }
    },
},
    
ajuda: {
description: 'Mostra todos os comandos dispon√≠veis.',
execute: (message) => {
const helpText = Object.keys(commands).map(cmd => `\`!${cmd}\`: ${commands[cmd].description}`).join('\n');
const embed = new EmbedBuilder()
.setColor('#3498db')
.setTitle('üìú Comandos Dispon√≠veis')
.setDescription(helpText)
.setFooter({
text: `üå† Danny Barbosa | ${formatDateTime()}`,
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();
message.channel.send({ embeds: [embed] });
},
},
    
//modificacao
banir: {
    description: 'Bane um servidor da lista de conex√µes.',
    execute: async (message, args) => {
        if (message.author.id !== OWNER_ID) {
            const embed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ùå Permiss√£o Negada')
                .setDescription('Apenas o dono do bot pode usar este comando.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            return message.channel.send({ embeds: [embed] });
        }

        const serverId = args[0];
        if (!serverId) {
            const embed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ùó ID do Servidor N√£o Informado')
                .setDescription('Por favor, forne√ßa o ID do servidor para banir.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            return message.channel.send({ embeds: [embed] });
        }

        if (!bannedServers.includes(serverId)) {
            bannedServers.push(serverId);
            saveConnections();

            // Notifica√ß√£o de sucesso para o usu√°rio que baniu
            const successEmbed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para banimento
                .setTitle('üö´ Servidor Banido')
                .setDescription(`O servidor **${serverId}** foi banido com sucesso.`)
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            message.channel.send({ embeds: [successEmbed] });

            // Remove os canais do servidor banido da lista global de conex√µes
            globalConnections = globalConnections.filter(channelId => {
                const channel = client.channels.cache.get(channelId);
                return channel && channel.guild.id !== serverId;
            });

            // Salva a lista de conex√µes atualizada
            saveConnections();

            // Notifica√ß√£o de banimento para todos os canais conectados restantes
            const banEmbed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para banimento
                .setTitle('üö´ Servidor Banido da Conex√£o Global')
                .setDescription(`O servidor **${serverId}** foi banido e desconectado da conex√£o global.`)
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            for (const channelId of globalConnections) {
                try {
                    const channel = await client.channels.fetch(channelId);
                    await channel.send({ embeds: [banEmbed] });
                } catch (err) {
                    console.log(`Erro ao enviar mensagem para o canal ${channelId}: ${err.message}`);
                }
            }
        } else {
            const alreadyBannedEmbed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ö†Ô∏è Servidor J√° Banido')
                .setDescription('Este servidor j√° est√° na lista de banidos.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            message.channel.send({ embeds: [alreadyBannedEmbed] });
        }
    },
},

desbanir: {
    description: 'Remove o banimento de um servidor.',
    execute: async (message, args) => {
        if (message.author.id !== OWNER_ID) {
            const embed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ùå Permiss√£o Negada')
                .setDescription('Apenas o dono do bot pode usar este comando.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            return message.channel.send({ embeds: [embed] });
        }

        const serverId = args[0];
        if (!serverId) {
            const embed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ùó ID do Servidor N√£o Informado')
                .setDescription('Por favor, forne√ßa o ID do servidor para desbanir.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            return message.channel.send({ embeds: [embed] });
        }

        const index = bannedServers.indexOf(serverId);
        if (index !== -1) {
            bannedServers.splice(index, 1);

            // Salva a lista atualizada de banidos ap√≥s remover o servidor
            saveConnections();

            // Notifica√ß√£o de desbanimento para todos os canais conectados
            const unbanEmbed = new EmbedBuilder()
                .setColor('#00FF00') // Verde para desbanimento
                .setTitle('‚úÖ Servidor Desbanido da Conex√£o Global')
                .setDescription(`O servidor **${serverId}** foi desbanido e pode se reconectar.`)
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();

            for (const channelId of globalConnections) {
                try {
                    const channel = await client.channels.fetch(channelId);
                    await channel.send({ embeds: [unbanEmbed] });
                } catch (err) {
                    console.log(`Erro ao enviar mensagem para o canal ${channelId}: ${err.message}`);
                }
            }
        } else {
            const alreadyUnbannedEmbed = new EmbedBuilder()
                .setColor('#FF0000') // Vermelho para erro
                .setTitle('‚ö†Ô∏è Servidor N√£o Banido')
                .setDescription('Este servidor n√£o est√° na lista de banidos.')
                .setFooter({
                    text: `üå† Danny Barbosa | ${formatDateTime()}`,
                    iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
                })
                .setTimestamp();
            message.channel.send({ embeds: [alreadyUnbannedEmbed] });
        }
    },
},
};

/// Parte 5Gerenciamento de eventos e compartilhamento de mensagens
client.once(Events.ClientReady, () => {
console.log(`üå† ${client.user.tag} est√° online`);
loadConnections();
});

// Ouve mensagens e verifica compartilhamentos globais
client.on(Events.MessageCreate, async (message) => {
if (message.author.bot) return;

// Verifica√ß√£o de comandos
if (message.content.startsWith('!')) {
const args = message.content.slice(1).trim().split(/ +/);
const commandName = args.shift().toLowerCase();

const command = commands[commandName];

if (command) {
    try {
        await command.execute(message, args);
    } catch (error) {
        console.error(`Erro ao executar o comando: ${error}`);

        // Embed de erro ao executar o comando
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000') // Cor vermelha para erro
            .setTitle('‚ùó Erro ao Executar Comando')
            .setDescription('Houve um erro ao executar esse comando.')
            .setFooter({
                text: `üå† Danny Barbosa | ${formatDateTime()}`,
                iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
            })
            .setTimestamp();

        message.channel.send({ embeds: [errorEmbed] });
    }
} else {
    // Embed para comando n√£o encontrado
    const notFoundEmbed = new EmbedBuilder()
        .setColor('#FFA500') // Cor laranja para aviso
        .setTitle('‚ùå Comando N√£o Encontrado')
        .setDescription('Comando n√£o encontrado.\nFa√ßa `!ajuda` para ver os comandos dispon√≠veis.')
        .setFooter({
            text: `üå† Danny Barbosa | ${formatDateTime()}`,
            iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
        })
        .setTimestamp();

    message.channel.send({ embeds: [notFoundEmbed] });
}
}
// Compartilhamento global de mensagens
if (globalConnections.includes(message.channel.id)) {
for (const targetChannelId of globalConnections) {
if (targetChannelId !== message.channel.id) {
const targetChannel = await client.channels.fetch(targetChannelId);
if (targetChannel) {
// Conte√∫do da mensagem
let embedDescription = message.content || "Mensagem sem conte√∫do.";
const embed = new EmbedBuilder()
.setColor('#3498db')
.setAuthor({ name: message.author.username, iconURL: message.author.displayAvatarURL() })
.setDescription(embedDescription)
.setFooter({
text: `üåé ${message.guild.name} | ${formatDateTime()}`, // Nome do servidor de origem
iconURL: 'https://avatars.githubusercontent.com/u/132908376?v=4',
})
.setTimestamp();

await targetChannel.send({ embeds: [embed] });
               
// Responder a mensagem original mencionando o autor
if (message.reference && message.reference.messageId) {
const originalMessage = await message.channel.messages.fetch(message.reference.messageId);
if (originalMessage) {
const replyContent = `üîÅ Resposta a ${originalMessage.author}:\n${originalMessage.content}`;

// Criar um embed para a resposta
const replyEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed da resposta (laranja)
.setDescription(replyContent)
.setFooter({ text: `Resposta de ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

// Enviar a resposta como um embed, mencionando a mensagem original
await targetChannel.send({ embeds: [replyEmbed], messageReference: { messageId: originalMessage.id } });
}
}
               
// Compartilhar anexos como links ou imagens embutidas
if (message.attachments.size > 0) {
message.attachments.forEach(async (attachment) => {
const isImage = attachment.contentType && attachment.contentType.startsWith('image');
const isAudio = attachment.contentType && attachment.contentType.startsWith('audio');
const isVideo = attachment.contentType && attachment.contentType.startsWith('video');
const isFile = !isImage && !isAudio && !isVideo;

if (isImage) {
const attachmentEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para imagens (laranja)
.setDescription(`üñºÔ∏è Imagem compartilhada \n[Veja a imagem aqui](${attachment.url})`) // Link da imagem inclu√≠do na descri√ß√£o
.setImage(attachment.url) // Imagem embutida no embed
.setFooter({ text: `Imagem enviada por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [attachmentEmbed] });
} else if (isAudio) {
const audioEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para √°udios (laranja)
.setDescription(`üé∂ √Åudio compartilhado \n[Ou√ßa o √°udio aqui](${attachment.url})`) // Link do √°udio inclu√≠do na descri√ß√£o
.setFooter({ text: `√Åudio enviado por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [audioEmbed] });
} else if (isVideo) {
const videoEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para v√≠deos (laranja)
.setDescription(`üé• V√≠deo compartilhado \n[Assista ao v√≠deo aqui](${attachment.url})`) // Link do v√≠deo inclu√≠do na descri√ß√£o
.setFooter({ text: `V√≠deo enviado por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [videoEmbed] });
} else if (isFile) {
const fileEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para outros tipos de arquivos (laranja)
.setDescription(`üìé Arquivo compartilhado \n[Baixe o arquivo aqui](${attachment.url})`) // Link do arquivo inclu√≠do na descri√ß√£o
.setFooter({ text: `Arquivo enviado por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [fileEmbed] });
}
});
}

// Compartilhar links compartilhados
if (message.content.includes('http')) {
const links = message.content.match(/https?:\/\/[^\s]+/g);
if (links) {
for (const link of links) {
const linkEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para links (laranja)
.setDescription(`üîó Link compartilhado \n[Acesse aqui](${link})`)
.setFooter({ text: `Link enviado por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [linkEmbed] });
}
}
}

// Compartilhar figurinhas
if (message.stickers.size > 0) {
message.stickers.forEach(async (sticker) => {
const stickerEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para figurinhas (laranja)
.setDescription(`üñºÔ∏è Figurinha compartilhada \n[Veja a figurinha aqui](${sticker.url})`) // Link da figurinha inclu√≠do na descri√ß√£o
.setFooter({ text: `Figurinha enviada por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [stickerEmbed] });
});
}

// Emojis de outros servidores
if (message.content.includes('<:')) {
const emojis = message.content.match(/<:.+?:\d+>/g);
if (emojis) {
for (const emoji of emojis) {
const emojiEmbed = new EmbedBuilder()
.setColor('#FFA500') // Cor do embed para emojis (laranja)
.setDescription(`üòÑ Emoji compartilhado: ${emoji}`)
.setFooter({ text: `Emoji enviado por ${message.author.tag}`, iconURL: message.author.displayAvatarURL() });

await targetChannel.send({ embeds: [emojiEmbed] });           

}
}
}
}
}
}
}
});
const sentMessages = new Set(); // Inicializa sentMessages como um Set

// Captura de mensagens de bots
client.on('messageCreate', async (message) => {
    // Verifica se a mensagem √© de um bot que n√£o √© ele mesmo
    if (message.author.bot && message.author.id !== client.user.id) {
        const { content, attachments } = message;

        // Verifica se o canal atual tem uma conex√£o global
        if (!globalConnections.includes(message.channel.id)) {
            return; // N√£o faz nada se o canal n√£o est√° conectado globalmente
        }

        // Verifica se a mensagem j√° foi enviada
        if (sentMessages.has(message.id)) {
            return; // Se j√° foi enviada, n√£o faz nada
        }

        // Adiciona o ID da mensagem ao conjunto para evitar duplica√ß√£o
        sentMessages.add(message.id);

        // Mensagem de texto do bot
        const botMessageEmbed = new EmbedBuilder()
            .setColor('#FFFF00') // Cor do embed (amarelo)
            .setDescription(`ü§ñ Mensagem do Bot: \n${content}`)
            .setFooter({ text: `Mensagem enviada por ${message.author.tag} | Servidor: ${message.guild.name}`, iconURL: message.author.displayAvatarURL() });

        // Enviar a mensagem embed para todos os canais globais conectados
        for (const channelId of globalConnections) {
            try {
                const channel = await client.channels.fetch(channelId);

                // Verifica se o canal √© v√°lido e se o bot j√° enviou mensagem
                if (channel) {
                    // Enviar a mensagem embed
                    await channel.send({ embeds: [botMessageEmbed] });

                    // Enviar anexos se existirem
                    if (attachments.size > 0) {
                        for (const attachment of attachments.values()) {
                            await channel.send({ files: [attachment.url] }); // Envia cada anexo
                        }
                    }
                }
            } catch (error) {
                console.log(`Canal ${channelId} n√£o encontrado, removendo da lista de conex√µes.`);
                globalConnections = globalConnections.filter(id => id !== channelId); // Remove o canal da lista
            }
        }
    }
});

//parte 6 final
/// Ready Event - Quando o bot fica online
client.once('ready', () => {
console.log(`Bot est√° ativo como ${client.user.tag}`);

// Mensagem de inicializa√ß√£o embutida
const embed = new EmbedBuilder()
.setTitle("üì∫ Bot Sintonizado!")
.setDescription("üå† Danny-Chat est√° **no ar** e pronto para usar!")
.setColor(0x00FF00)
.setThumbnail("https://avatars.githubusercontent.com/u/132908376?v=4")
.setTimestamp()
.setFooter({ text: `${client.guilds.cache.first()?.name} - Conectando Comunidades` });

// Envia a mensagem em todos os canais globais conectados
globalConnections.forEach(async (channelId) => {
const channel = await client.channels.fetch(channelId).catch(console.error);
if (channel && channel.isTextBased()) {
channel.send({ embeds: [embed] }).catch(console.error);
}
});
});
/// Shutdown Event - Quando o bot √© desligado

client.login(TOKEN)
.then(() => {
console.log('Bot logado com sucesso!');
})
.catch(error => {
console.error('Erro ao logar o bot: ', error);
});
